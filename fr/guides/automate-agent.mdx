---
title: "Tutoriel : Mettre à jour automatiquement la documentation lorsque le code change"
sidebarTitle: "Automatiser les mises à jour de la documentation"
description: "Utilisez l’API de l’agent pour mettre à jour automatiquement votre documentation."
keywords: ["automatisation avec agent", "n8n", "GitHub Actions", "mises à jour automatiques de la documentation"]
---

<div id="what-you-will-build">
  ## Ce que vous allez construire
</div>

Une automatisation qui met à jour votre documentation lorsqu’un code est poussé sur votre branche principale. Le workflow peut être créé sur plusieurs plateformes, notamment GitHub Actions et n8n. Il surveille votre référentiel de code, puis appelle l’API de l’agent pour mettre à jour votre documentation dans un référentiel de documentation distinct.

Ce workflow relie deux référentiels distincts :

- **Référentiel de code** : l’endroit où vous stockez le code de l’application. Vous y configurerez le déclencheur d’automatisation. Exemples : une API backend, une application frontend, un SDK ou un outil CLI.
- **Référentiel de documentation** : l’endroit où vous stockez votre documentation et que vous connectez à votre projet Mintlify. L’agent crée des pull requests (demandes de fusion) contenant des mises à jour de la documentation dans ce référentiel.

Ce tutoriel part du principe que votre documentation se trouve dans un référentiel distinct de votre code applicatif. Si vous utilisez un monorepo, modifiez le workflow pour cibler le répertoire où vous stockez votre documentation.

<div id="workflow-overview">
  ### Vue d’ensemble du workflow
</div>

1. Quelqu’un pousse du code sur votre branche principale.
2. Le workflow se déclenche.
3. Le workflow appelle l’API de l’agent pour mettre à jour votre documentation.
4. L’agent crée une pull request (demande de fusion) contenant les mises à jour de la documentation dans votre référentiel de documentation.

<div id="choose-your-platform">
  ## Choisissez votre plate-forme
</div>

<Tabs>
  <Tab title="GitHub Actions">
    GitHub Actions est l&#39;option la plus simple si votre code est déjà sur GitHub. Aucun service supplémentaire n&#39;est requis.

    ## Prérequis

    * GitHub Actions activé sur vos dépôts de code et de documentation
    * [Clé API d’administration Mintlify](https://dashboard.mintlify.com/settings/organization/api-keys)
    * [ID du projet Mintlify](https://dashboard.mintlify.com/settings/organization/api-keys)
    * [Abonnement Pro ou Custom de Mintlify](https://mintlify.com/pricing)
    * Accès administrateur aux dépôts GitHub de votre code et de votre documentation

    ### Obtenez votre clé API d&#39;administration

    1. Accédez à la page [API keys](https://dashboard.mintlify.com/settings/organization/api-keys) dans votre Dashboard.
    2. Sélectionnez **Create Admin API key**.
    3. Copiez la key et conservez-la en lieu sûr.

    ## Construire le workflow

    ### Créer le fichier de workflow

    1. Dans votre référentiel de code, créez un nouveau fichier : `.github/workflows/update-docs.yml`
    2. Ajoutez ce flux de travail :

       ```yaml
       name: Mettre à jour la documentation

       on:
       push:
           branches:
           - main

       jobs:
       update-docs:
           runs-on: ubuntu-latest
           steps:
           - uses: actions/github-script@v8
               env:
               MINTLIFY_API_KEY: ${{ secrets.MINTLIFY_API_KEY }}
               PROJECT_ID: ${{ secrets.MINTLIFY_PROJECT_ID }}
               with:
               script: |
                   const { owner, repo } = context.repo;
                   const projectId = process.env.PROJECT_ID;
                   const apiKey = process.env.MINTLIFY_API_KEY;

                   if (!projectId || !apiKey) {
                   core.setFailed('Secrets MINTLIFY_PROJECT_ID ou MINTLIFY_API_KEY manquants');
                   return;
                   }

                   const url = `https://api.mintlify.com/v1/agent/${projectId}/job`;
                   const payload = {
                   branch: `mintlify/docs-update-${Date.now()}`,
                   messages: [
                       {
                       role: 'system',
                       content: 'Vous êtes un exécuteur d'action qui met à jour la documentation en fonction des modifications du code. Vous ne devez jamais poser de questions. Si vous ne parvenez pas à accéder au référentiel, signalez l'erreur et quittez.'
                       },
                       {
                       role: 'user',
                       content: `Mettez à jour la documentation pour nos récents pushs vers main :\n\nRéférentiel : ${owner}/${repo}`
                       }
                   ]
                   };

                   try {
                       const response = await fetch(url, {
                       method: 'POST',
                       headers: {
                           'Authorization': `Bearer ${apiKey}`,
                           'Content-Type': 'application/json'
                       },
                       body: JSON.stringify(payload)
                       });

                       if (!response.ok) {
                       throw new Error(`La requête API a échoué avec le statut ${response.status} : ${await response.text()}`);
                       }

                       const reader = response.body.getReader();
                       const decoder = new TextDecoder();
                       let buffer = '';

                       while (true) {
                       const { done, value } = await reader.read();
                       if (done) break;
                       buffer += decoder.decode(value, { stream: true });
                       const lines = buffer.split('\n');
                       buffer = lines.pop() || '';
                       for (const line of lines) {
                           if (line.trim()) {
                           console.log(line);
                           }
                       }
                       }
                       if (buffer.trim()) {
                       console.log(buffer);
                       }

                       core.notice(`Tâche de mise à jour de la documentation déclenchée pour ${owner}/${repo}`);
                   } catch (error) {
                       core.setFailed(`Échec de la création de la tâche de mise à jour de la documentation : ${error.message}`);
                   }
       ```

    ### Ajouter des secrets

    1. Dans votre référentiel de code, accédez à **Settings** → **Secrets and variables** → **Actions**.
    2. Cliquez sur **Nouveau secret du référentiel**.
    3. Ajoutez les secrets suivants :
       * Nom : `MINTLIFY_API_KEY`, Secret : votre clé API administrateur Mintlify
       * Nom : `MINTLIFY_PROJECT_ID`, Secret : votre ID de projet Mintlify (disponible sur la page [API keys](https://dashboard.mintlify.com/settings/organization/api-keys) de votre Dashboard)

    Pour plus d&#39;informations, consultez [Utilisation des secrets dans GitHub Actions](https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets) dans la documentation GitHub.

    ## Tester l&#39;automatisation

    1. Apportez une petite modification à votre référentiel de code et poussez-la sur la branche principale :
       ```bash
       git add .
       git commit -m "Test: trigger docs automation"
       git push origin main
       ```

    2. Consultez l’onglet **Actions** de votre référentiel de code pour voir le workflow en cours d’exécution.

    3. Une fois le workflow exécuté, vérifiez votre référentiel de documentation pour une nouvelle branche et une pull request (demande de fusion) contenant des mises à jour de la documentation.

    ## Dépannage

    ### Le workflow ne s&#39;exécute pas

    * Vérifiez que GitHub Actions est activé dans votre référentiel de code.
    * Consultez l’onglet **Actions** pour voir les messages d’erreur.
    * Assurez-vous que le fichier de workflow se trouve dans `.github/workflows/` et porte l’extension `.yml`.

    ### Erreur 401 de l&#39;API de l&#39;agent

    * Vérifiez que votre clé d’API commence par `mint_`.
    * Vérifiez que l’en-tête Authorization est au format « Bearer mint&#95;yourkey ».
    * Vérifiez que la clé API correspond à la bonne organisation Mintlify.

    ### Les mises à jour de la documentation n&#39;apparaissent pas

    * Vérifiez que le référentiel de documentation est bien connecté à votre projet Mintlify.
    * Vérifiez que l’agent dispose des droits d’écriture sur le référentiel de documentation.
    * Consultez les journaux du workflow pour y trouver les messages d’erreur de l’agent.
  </Tab>

  <Tab title="n8n">
    n8n fournit un éditeur de workflow visuel et peut s&#39;intégrer à plusieurs services.

    ## Prérequis

    * espace de travail n8n
    * Clé API d’administration Mintlify
    * [Forfait Pro ou forfait personnalisé Mintlify](https://mintlify.com/pricing)
    * Accès administrateur aux dépôts GitHub de votre code et de votre documentation
    * Jeton d’accès personnel GitHub

    ### Obtenez votre clé API d&#39;administration

    1. Accédez à la page [API keys](https://dashboard.mintlify.com/settings/organization/api-keys) de votre Dashboard.
    2. Sélectionnez **Create Admin API key**.
    3. Copiez la key et conservez-la en lieu sûr.

    ### Obtenez votre jeton d&#39;accès personnel GitHub

    1. Dans GitHub, accédez à **Settings**.
    2. Cliquez sur **Paramètres développeur**.
    3. Cliquez sur **Jetons d’accès personnels**.
    4. Cliquez sur **Jetons (classique)**.
    5. Cliquez sur **Générer un nouveau jeton (classique)**.
    6. Sélectionnez ces scopes :
       * `repo` (contrôle total des dépôts privés)
       * `admin:repo_hook` (si vous voulez que n8n crée des webhooks)
    7. Générez et enregistrez le jeton en toute sécurité.

    Pour plus d&#39;informations, consultez [Creating a personal access token (classic)](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens?versionId=free-pro-team%40latest\&productId=account-and-profile#creating-a-personal-access-token-classic) dans la documentation de GitHub.

    ## Construire le workflow

    ### Créer le déclencheur de webhook

    1. Dans n8n, créez un nouveau flux de travail.
    2. Ajoutez un nœud de webhook.
    3. Configurer le webhook :
       * Méthode HTTP : `POST`
       * Chemin : `auto-update-documentation` (ou tout chemin unique)
       * Authentification : aucune
       * Répondre : immédiatement
    4. Enregistrez le flux de travail.
    5. Copiez l’URL du webhook de production. Elle ressemble à : `https://your-n8n-instance.app.n8n.cloud/webhook/auto-update-documentation`

    <Frame>
      <img
        src="/images/guides/n8n/webhook-node.png"
        alt="Capture d’écran des paramètres du nœud webhook."
        style={{
width: 'auto',
height: '700px',
}}
      />
    </Frame>

    ### Configurer le webhook GitHub

    1. Accédez à votre référentiel de code sur GitHub.
    2. Cliquez sur **Settings**.
    3. Cliquez sur **Webhooks**.
    4. Cliquez sur **Add webhook**.
    5. Configurer le webhook :
       * URL de la charge utile : collez votre URL de webhook n8n
       * Type de contenu : `application/json`
       * Quels événements souhaitez-vous utiliser pour déclencher ce webhook ?
         * Sélectionnez **Me laisser choisir des événements individuellement.**
         * Sélectionnez uniquement **Événements de push**.
       * Sélectionnez **Actif**
    6. Cliquez sur **Add webhook**.

    ### Filtrer les pushs vers la branche principale

    Ajoutez un nœud de code après le webhook pour filtrer les pushs vers main et extraire les informations pertinentes.

    1. Ajouter un nœud de code.
    2. Nommez-le « Filtrer les pushs principaux. »
    3. Définissez le mode sur **Exécuter une fois pour tous les éléments**.
    4. Ajoutez ce code JavaScript :

    ```javascript
    const webhookData = $input.first().json.body;

    // Continuer uniquement s'il s'agit d'un push vers main
    if (webhookData.ref !== "refs/heads/main") {
      return [];
    }

    // Extraire les informations
    const repository = webhookData.repository;
    const pusher = webhookData.pusher;

    // Construire le message pour l'agent
    const agentMessage = `Mettre à jour la documentation pour les modifications poussées vers main dans ${repository.name}. Toujours modifier les fichiers et créer une pull request (demande de fusion).`;

    return {
      json: {
        codeRepoName: repository.full_name,
        codeRepoShortName: repository.name,
        agentMessage: agentMessage
      }
    };
    ```

    <Frame>
      <img src="/images/guides/n8n/filter-merged-PRs-node.png" alt="Capture d’écran des paramètres du nœud de filtrage des pushs sur la branche principale." />
    </Frame>

    Ce code arrête le workflow si le push n&#39;a pas été effectué vers main, extrait toutes les informations pertinentes du webhook GitHub et crée un message pour l&#39;API de l&#39;agent.

    ### Appeler l&#39;API de l&#39;agent

    Ajoutez un nœud de requête HTTP pour créer un job de documentation.

    1. Ajoutez un nœud de requête HTTP.
    2. Nommez-le « Créer une tâche d’agent. »
    3. Configurer la requête :

       * Méthode : `POST`
       * URL : `https://api.mintlify.com/v1/agent/YOUR_PROJECT_ID/job` (remplacez `YOUR_PROJECT_ID` par l’ID de votre projet depuis la page [API keys](https://dashboard.mintlify.com/settings/organization/api-keys))
       * Authentification : Type d’identifiants générique → Authentification par en-tête
         * Créez de nouveaux identifiants :
           * Nom : `Authorization`
           * Value: `Bearer mint_YOUR_API_KEY` (remplacez par votre clé API)
       * Envoi du corps : Activé
       * Type de contenu du corps : JSON
       * Spécifier le corps : JSON
       * Ajoutez ce JSON :

       ```json
       {
       "branch": "docs-update-from-{{ $json.codeRepoShortName }}-{{ $now.toISOString() }}",
       "messages": [
           {
           "role": "system",
           "content": "{{ $json.agentMessage }}"
           }
       ]
       }
       ```

    <Frame>
      <img
        src="/images/guides/n8n/create-agent-job-node.png"
        alt="Capture d’écran des paramètres du nœud Create Agent Job."
        style={{
width: 'auto',
height: '700px',
}}
      />
    </Frame>

    L&#39;agent crée une pull request (demande de fusion) dans votre référentiel de documentation en utilisant un nom de branche descriptif qui inclut le nom du référentiel d&#39;origine et l&#39;horodatage.

    ### Activer le workflow

    1. Enregistrez votre flux de travail.
    2. Activez-le.

    Votre workflow surveille maintenant votre référentiel de code pour les pushs vers main.

    <Frame>
      <img src="/images/guides/n8n/workflow.png" alt="Capture d’écran du flux d’automatisation dans l’éditeur n8n." />
    </Frame>

    ## Tester l&#39;automatisation

    1. Créez une branche de test dans votre référentiel de code :
       ```bash
       git checkout -b test-docs-automation
       ```

    2. Apportez une petite modification et faites un commit :
       ```bash
       git add .
       git commit -m "Test : déclencher l'automatisation de la documentation"
       git push origin test-docs-automation
       ```

    3. Ouvrez une pull request (demande de fusion) sur GitHub.

    4. Fusionnez la pull request (demande de fusion).

    ### Vérifier l&#39;automatisation

    Vous devriez voir une nouvelle exécution n8n avec tous les nœuds terminés avec succès, ainsi qu&#39;une nouvelle branche et une pull request dans votre référentiel de documentation.

    ## Dépannage

    ### Le webhook ne se déclenche pas

    * Vérifiez que le flux de travail est actif dans n8n.
    * Consultez le code de réponse dans Paramètres du référentiel GitHub → Webhooks → Livraisons récentes.
    * Vérifiez que l’URL du webhook correspond exactement à votre URL de webhook n8n.

    ### Erreur 401 de l&#39;API de l&#39;agent

    * Vérifiez que votre API key commence par `mint_`.
    * Vérifiez que l’en-tête Authorization est au format `Bearer mint_yourkey`.
    * Vérifiez que la clé API correspond à la bonne organisation Mintlify.

    ### Erreur 401 de GitHub

    * Vérifiez que votre jeton dispose de l’étendue `repo`.
    * Vérifiez que le jeton n’est pas expiré.
    * Vérifiez que vous avez inclus l’en-tête `User-Agent` dans la requête GitHub.
  </Tab>
</Tabs>