---
title: "Configuration de la personnalisation"
description: "Permettez aux utilisateurs de se connecter pour une expérience de documentation personnalisée"
icon: "user-cog"
---

La personnalisation adapte votre documentation à chaque utilisateur lorsqu’il est connecté. Par exemple, vous pouvez préremplir leurs clés d’API, afficher du contenu propre à leur forfait ou à leur rôle, ou masquer les sections dont ils n’ont pas besoin.



<div id="personalization-features">
  ## Fonctionnalités de personnalisation
</div>

Personnalisez le contenu grâce à ces fonctionnalités de personnalisation.

<div id="api-key-prefilling">
  ### Préremplissage de clé d’API
</div>

Renseignez automatiquement les champs du bac à sable d’API avec des valeurs propres à chaque utilisateur en renvoyant des noms de champs identiques dans vos données utilisateur. Les noms de champs dans vos données utilisateur doivent correspondre exactement à ceux du bac à sable d’API pour que le préremplissage automatique fonctionne.

<div id="dynamic-mdx-content">
  ### Contenu MDX dynamique
</div>

Affichez un contenu dynamique en fonction d’informations utilisateur comme le nom, l’offre ou l’organisation à l’aide de la variable `user`.

```jsx
Bon retour, {user.firstName} ! Votre forfait {user.org?.plan} inclut...
```

Voir la section [Format des données utilisateur](#user-data-format) ci-dessous pour des exemples détaillés et des conseils de mise en œuvre.

<div id="page-visibility">
  ### Visibilité des pages
</div>

Limitez les pages visibles par vos utilisateurs en ajoutant des champs `groups` au frontmatter de vos pages. Par défaut, chaque page est visible par chaque utilisateur.

Les utilisateurs ne verront que les pages des `groups` auxquels ils appartiennent.

```mdx
---
title: "Gestion de vos utilisateurs"
description: "Ajouter et supprimer des utilisateurs de votre organisation"
groups: ["admin"]
---
```


<div id="user-data-format">
  ## Format des données utilisateur
</div>

Lors de la mise en place de la personnalisation, votre système renvoie des données utilisateur dans un format spécifique qui permet d’adapter le contenu. Ces données peuvent être envoyées soit sous forme d’objet JSON brut, soit dans un JWT (JSON Web Token) signé, selon votre méthode d’échange. La structure des données est identique dans les deux cas.

```tsx
type User = {
  expiresAt?: number;
  groups?: string[];
  content?: Record<string, any>;
  apiPlaygroundInputs?: {
    header?: Record<string, any>;
    query?: Record<string, any>;
    cookie?: Record<string, any>;
    server?: Record<string, string>;
  };
};
```

<ParamField path="expiresAt" type="number">
  Durée d’expiration de la session en **secondes depuis l’époque Unix**. Si l’utilisateur charge une page après ce moment, ses données stockées sont automatiquement supprimées et il doit se reconnecter.
  <Warning><b>Pour les échanges JWT :</b> Ceci diffère de l’attribut `exp` du JWT, qui détermine quand un JWT est considéré comme invalide. Pour des raisons de sécurité, définissez l’attribut `exp` du JWT sur une durée courte (10 secondes ou moins). Utilisez `expiresAt` pour la durée réelle de la session (de quelques heures à plusieurs semaines).</Warning>
</ParamField>

<ParamField path="groups" type="string[]">
  Liste des groupes auxquels l’utilisateur appartient. Les pages dont le frontmatter contient des `groups` correspondants sont visibles par cet utilisateur.

  **Exemple** : Un utilisateur avec `groups: ["admin", "engineering"]` peut accéder aux pages étiquetées avec les groupes `admin` ou `engineering`.
</ParamField>

<ParamField path="content" type="object">
  Données personnalisées accessibles dans votre contenu `MDX` via la variable `user`. Utilisez-les pour une personnalisation dynamique dans toute votre documentation.

  **Exemple de base** :

  ```json
  { "firstName": "Ronan", "company": "Acme Corp", "plan": "Enterprise" }
  ```

  **Utilisation dans `MDX`** :

  ```mdx
  Welcome back, {user.firstName}! Your {user.plan} plan includes...
  ```

  Avec l’exemple de données `user`, le rendu serait : Welcome back, Ronan! Your Enterprise plan includes...

  **Rendu conditionnel avancé** :

  ```jsx
  Authentication is an enterprise feature. {
    user.org === undefined
      ? <>To access this feature, first create an account at the <a href="https://dashboard.mintlify.com/login">Mintlify dashboard</a>.</>
      : user.org.plan !== 'enterprise'
        ? <>You are currently on the ${user.org.plan ?? 'free'} plan. See <a href="https://mintlify.com/pricing">our pricing page</a> for information about upgrading.</>
        : <>To request this feature for your enterprise org, contact your admin.</>
  }
  ```

  <Note>
    Les informations dans `user` ne sont disponibles que pour les utilisateurs connectés. Pour les utilisateurs déconnectés, la valeur de `user` sera `{}`. Pour éviter que la page ne plante pour les utilisateurs déconnectés, utilisez toujours l’opérateur d’enchaînement optionnel sur vos champs `user`. Par exemple, `{user.org?.plan}`.
  </Note>
</ParamField>

<ParamField path="apiPlaygroundInputs" type="object">
  Valeurs propres à l’utilisateur qui préremplissent les champs du bac à sable d’API. Elles font gagner du temps aux utilisateurs en remplissant automatiquement leurs données lors des tests d’API.

  **Exemple** :

  ```json
  {
    "header": { "X-API-Key": "user_api_key_123" },
    "server": { "subdomain": "foo" },
    "query": { "org_id": "12345" }
  }
  ```

  Si un utilisateur effectue des requêtes sur un sous-domaine spécifique, vous pouvez envoyer `{ server: { subdomain: 'foo' } }` comme champ `apiPlaygroundInputs`. Cette valeur sera préremplie sur toute page d’API avec la clé `subdomain`.

  <Note>Les champs `header`, `query` et `cookie` ne seront préremplis que s’ils font partie de votre [schéma de sécurité OpenAPI](https://swagger.io/docs/specification/authentication/). Si un champ se trouve dans les sections `Authorization` ou `Server`, il sera prérempli. Créer un paramètre d’en-tête standard nommé `Authorization` n’activera pas cette fonctionnalité.</Note>
</ParamField>

<div id="example-user-data">
  ### Exemple de données utilisateur
</div>

```json
{
  "expiresAt": 1735689600,
  "groups": ["admin", "beta-users"],
  "content": {
    "firstName": "Jeanne",
    "lastName": "Dupont",
    "company": "TechCorp",
    "plan": "Entreprise",
    "region": "us-west"
  },
  "apiPlaygroundInputs": {
    "header": {
      "Authorization": "Bearer abc123",
      "X-Org-ID": "techcorp"
    },
    "server": {
      "environment": "production",
      "region": "us-west"
    }
  }
}
```


<div id="configuring-personalization">
  ## Configuration de la personnalisation
</div>

Sélectionnez la méthode de poignée de main que vous souhaitez configurer.



<Tabs>
  <Tab title="JWT (JSON Web Token)">
    ### Prérequis

    * Un système d’authentification capable de générer et de signer des JWT
    * Un service backend capable de créer des URL de redirection

    ### Implémentation

    <Steps>
      <Step title="Générez une clé privée.">
        1. Dans votre Dashboard, accédez à [Authentification](https://dashboard.mintlify.com/settings/deployment/authentication).
        2. Sélectionnez **Personnalisation**.
        3. Sélectionnez **JWT**.
        4. Saisissez l’URL de votre flux de connexion existant puis sélectionnez **Enregistrer les modifications**.
        5. Sélectionnez **Generate new key**.
        6. Stockez votre key en lieu sûr, accessible par votre backend.
      </Step>

      <Step title="Intégrez la personnalisation Mintlify à votre flux de connexion.">
        Modifiez votre flux de connexion existant pour inclure ces étapes après la connexion de l’utilisateur :

        * Créez un JWT contenant les informations de l’utilisateur connecté au format `User`. Consultez la section [User data format](#user-data-format) ci-dessus pour plus d’informations.
        * Signez le JWT avec la clé secrète, en utilisant l’algorithme ES256.
        * Créez une URL de redirection vers votre documentation, en incluant le JWT comme hash.
      </Step>
    </Steps>

    ### Exemple

    Votre documentation est hébergée sur `docs.foo.com`. Vous souhaitez que votre documentation soit distincte de votre Dashboard (ou vous n’avez pas de Dashboard) et activer la personnalisation.

    Générez un secret JWT. Créez ensuite un endpoint de connexion à `https://foo.com/docs-login` qui lance un flux de connexion vers votre documentation.

    Après vérification des identifiants de l’utilisateur :

    * Générez un JWT avec les données utilisateur au format Mintlify.
    * Signez le JWT et redirigez vers `https://docs.foo.com#{SIGNED_JWT}`.

    ```ts
    import * as jose from 'jose';
    import { Request, Response } from 'express';

    const TWO_WEEKS_IN_MS = 1000 * 60 * 60 * 24 * 7 * 2;

    const signingKey = await jose.importPKCS8(process.env.MINTLIFY_PRIVATE_KEY, 'ES256');

    export async function handleRequest(req: Request, res: Response) {
      const user = {
        expiresAt: Math.floor((Date.now() + TWO_WEEKS_IN_MS) / 1000),
        groups: res.locals.user.groups,
        content: {
          firstName: res.locals.user.firstName,
          lastName: res.locals.user.lastName,
        },
      };

      const jwt = await new jose.SignJWT(user)
        .setProtectedHeader({ alg: 'ES256' })
        .setExpirationTime('10 s')
        .sign(signingKey);

      return res.redirect(`https://docs.foo.com#${jwt}`);
    }
    ```

    ### Préserver les ancres de page

    Pour rediriger les utilisateurs vers des sections spécifiques après connexion, utilisez ce format d’URL : `https://docs.foo.com/page#jwt={SIGNED_JWT}&anchor={ANCHOR}`.

    **Exemple** :

    * URL d’origine : `https://docs.foo.com/quickstart#step-one`
    * URL de redirection : `https://docs.foo.com/quickstart#jwt={SIGNED_JWT}&anchor=step-one`
  </Tab>

  <Tab title="OAuth 2.0">
    ### Prérequis

    * Un serveur OAuth qui prend en charge le flux Code d’autorisation avec PKCE
    * La possibilité de créer un endpoint d’API accessible par des jetons d’accès OAuth

    ### Implémentation

    <Steps>
      <Step title="Créer un endpoint d’API d’informations utilisateur.">
        Créez un endpoint d’API qui :

        * Accepte les jetons d’accès OAuth pour l’authentification.
        * Renvoie les données utilisateur au format `User`. Voir la section [User data format](#user-data-format) ci-dessus pour plus d’informations.
        * Définit les scopes d’accès.
      </Step>

      <Step title="Configurer vos paramètres de personnalisation OAuth.">
        1. Dans votre Dashboard, accédez à [Authentication](https://dashboard.mintlify.com/settings/deployment/authentication).
        2. Sélectionnez **Personalization**.
        3. Sélectionnez **OAuth** et configurez ces champs :

        * **Authorization URL** : votre endpoint d’autorisation OAuth.
        * **Client ID** : votre identifiant client OAuth 2.0.
        * **Scopes** : permissions à demander. Copiez la chaîne de scope **entière** (par exemple, pour un scope comme `provider.users.docs`, copiez l’intégralité de `provider.users.docs`). Doit correspondre aux scopes de l’endpoint configuré à la première étape.
        * **Token URL** : votre endpoint d’échange de jeton OAuth.
        * **Info API URL** : endpoint pour récupérer les données utilisateur pour la personnalisation. Créé à la première étape.

        4. Sélectionnez **Enregistrer les modifications**
      </Step>

      <Step title="Configurer votre serveur OAuth.">
        1. Copiez la **Redirect URL** depuis vos [authentication settings](https://dashboard.mintlify.com/settings/deployment/authentication).
        2. Ajoutez cette URL comme URL de redirection autorisée dans la configuration de votre serveur OAuth.
      </Step>
    </Steps>

    ### Exemple

    Votre documentation est hébergée sur `foo.com/docs` et vous disposez d’un serveur OAuth existant qui prend en charge le flux PKCE. Vous souhaitez personnaliser votre documentation en fonction des données utilisateur.

    **Créez un endpoint d’informations utilisateur** à `api.foo.com/docs/user-info`, qui nécessite un jeton d’accès OAuth avec le scope `provider.users.docs` et renvoie les données personnalisées de l’utilisateur :

    ```json
    {
      "content": {
        "firstName": "Jane",
        "lastName": "Doe"
      },
      "groups": ["engineering", "admin"]
    }
    ```

    **Configurez les paramètres de votre serveur OAuth** dans votre Dashboard :

    * **URL d’autorisation** : `https://auth.foo.com/authorization`
    * **Client ID** : `ydybo4SD8PR73vzWWd6S0ObH`
    * **Scopes** : `['docs-user-info']`
    * **URL du jeton** : `https://auth.foo.com/exchange`
    * **URL de l’API Info** : `https://api.foo.com/docs/user-info`

    **Configurez votre serveur OAuth** pour autoriser les redirections vers votre URL de rappel.
  </Tab>

  <Tab title="Session partagée">
    ### Prérequis

    * Un Dashboard ou portail utilisateur avec une authentification de session basée sur des cookies.
    * Possibilité de créer un endpoint d’API sur la même origine ou le même sous-domaine que votre Dashboard.
      * Si votre Dashboard est sur `foo.com`, l’**URL de l’API** doit commencer par `foo.com` ou `*.foo.com`.
      * Si votre Dashboard est sur `dash.foo.com`, l’**URL de l’API** doit commencer par `dash.foo.com` ou `*.dash.foo.com`.
    * Votre documentation est hébergée sur le même domain ou sous-domaine que votre Dashboard.
      * Si votre Dashboard est sur `foo.com`, vos **docs** doivent être hébergées sur `foo.com` ou `*.foo.com`.
      * Si votre Dashboard est sur `*.foo.com`, vos **docs** doivent être hébergées sur `foo.com` ou `*.foo.com`.

    ### Implémentation

    <Steps>
      <Step title="Create user info API endpoint.">
        Créez un endpoint d’API qui :

        * Utilise votre authentification de session existante pour identifier les utilisateurs
        * Renvoie les données utilisateur au format `User` (voir la section [Format des données utilisateur](#user-data-format) ci-dessus)
        * Si le domain de l’API et le domain des docs **ne correspondent pas exactement** :

          * Ajoutez le domain des docs à l’en-tête `Access-Control-Allow-Origin` de votre API (ne doit pas être `*`).
          * Définissez l’en-tête `Access-Control-Allow-Credentials` de votre API sur `true`.

          <Warning>
            Activez les en-têtes CORS uniquement sur cet endpoint spécifique, pas sur l’ensemble de votre API de Dashboard.
          </Warning>
      </Step>

      <Step title="Configure your personalization settings">
        1. Dans votre Dashboard, accédez à [Authentification](https://dashboard.mintlify.com/settings/deployment/authentication).
        2. Sélectionnez **Personnalisation**.
        3. Sélectionnez **Session partagée**.
        4. Renseignez votre **URL de l’API Info**, c’est l’endpoint de la première étape.
        5. Renseignez votre **URL de connexion**, où les utilisateurs se connectent à votre Dashboard.
        6. Sélectionnez **Enregistrer les modifications**.
      </Step>
    </Steps>

    ### Exemples

    #### Dashboard sur un sous-domaine, docs sur un sous-domaine

    Vous avez un Dashboard sur `dash.foo.com`, qui utilise une authentification de session basée sur des cookies. Les routes d’API de votre Dashboard sont hébergées sur `dash.foo.com/api`. Vous souhaitez configurer la personnalisation pour vos docs hébergées sur `docs.foo.com`.

    **Processus de configuration** :

    1. **Créez l’endpoint** `dash.foo.com/api/docs/user-info` qui identifie les utilisateurs via l’authentification de session et renvoie leurs données utilisateur.
    2. **Ajoutez les en-têtes CORS** pour cette route uniquement :
       * `Access-Control-Allow-Origin` : `https://docs.foo.com`
       * `Access-Control-Allow-Credentials` : `true`
    3. **Configurez l’URL de l’API** dans les paramètres d’authentification : `https://dash.foo.com/api/docs/user-info`.

    #### Dashboard sur un sous-domaine, docs à la racine

    Vous avez un Dashboard sur `dash.foo.com`, qui utilise une authentification de session basée sur des cookies. Les routes d’API de votre Dashboard sont hébergées sur `dash.foo.com/api`. Vous souhaitez configurer la personnalisation pour vos docs hébergées sur `foo.com/docs`.

    **Processus de configuration** :

    1. **Créez l’endpoint** `dash.foo.com/api/docs/user-info` qui identifie les utilisateurs via l’authentification de session et renvoie leurs données utilisateur.
    2. **Ajoutez les en-têtes CORS** pour cette route uniquement :
       * `Access-Control-Allow-Origin` : `https://foo.com`
       * `Access-Control-Allow-Credentials` : `true`
    3. **Configurez l’URL de l’API** dans les paramètres d’authentification : `https://dash.foo.com/api/docs/user-info`.

    #### Dashboard à la racine, docs à la racine

    Vous avez un Dashboard sur `foo.com/dashboard`, qui utilise une authentification de session basée sur des cookies. Les routes d’API de votre Dashboard sont hébergées sur `foo.com/api`. Vous souhaitez configurer la personnalisation pour vos docs hébergées sur `foo.com/docs`.

    **Processus de configuration** :

    1. **Créez l’endpoint** `foo.com/api/docs/user-info` qui identifie les utilisateurs via l’authentification de session et renvoie leurs données utilisateur.
    2. **Configurez l’URL de l’API** dans les paramètres d’authentification : `https://foo.com/api/docs/user-info`

    <Note>
      Aucune configuration CORS n’est nécessaire puisque le Dashboard et les docs partagent le même domain.
    </Note>
  </Tab>
</Tabs>


