---
title: "Cloudflare"
description: "Aloja la documentación en una subruta personalizada con Cloudflare Workers"
---

import Propagating from "/snippets/es/custom-subpath-propagating.mdx";

Para alojar tu documentación en una subruta personalizada como `yoursite.com/docs` con Cloudflare, deberás crear y configurar un Cloudflare Worker.

<Info>
  Antes de empezar, necesitas una cuenta de Cloudflare y un nombre de dominio (puede administrarse dentro o fuera de Cloudflare).
</Info>


<div id="repository-structure">
  ## Estructura del repositorio
</div>

Los archivos de documentación deben organizarse dentro del repositorio para que coincidan con la subruta elegida. Por ejemplo, si quieres que tu documentación esté en `yoursite.com/docs`, crea un directorio `docs/` con todos los archivos de documentación.

<div id="set-up-a-cloudflare-worker">
  ## Configurar un Cloudflare Worker
</div>

Crea un Cloudflare Worker siguiendo la [guía de inicio de Cloudflare Workers](https://developers.cloudflare.com/workers/get-started/dashboard/) si aún no lo has hecho.

<Warning>
  Si tu proveedor de DNS es Cloudflare, no habilites el proxy para el registro CNAME.
</Warning>

<div id="proxies-with-vercel-deployments">
  ### Proxies con implementaciones de Vercel
</div>

Si usas Cloudflare como proxy con implementaciones de Vercel, asegúrate de configurarlo correctamente para evitar conflictos con la verificación de dominio de Vercel y el aprovisionamiento de certificados SSL.

Una configuración de proxy incorrecta puede impedir que Vercel emita certificados SSL de Let's Encrypt y provocar errores en la verificación de dominio.

<div id="required-path-allowlist">
  #### Lista de rutas permitidas obligatoria
</div>

Tu Cloudflare Worker debe permitir el tráfico a estas rutas específicas sin bloquear ni redirigir:

- `/.well-known/acme-challenge/*` - Necesario para la verificación del certificado de Let's Encrypt
- `/.well-known/vercel/*` - Necesario para la verificación de dominios en Vercel

Si bien Cloudflare gestiona automáticamente muchas reglas de verificación, crear reglas personalizadas adicionales podría bloquear inadvertidamente este tráfico crítico.

<div id="header-forwarding-requirements">
  #### Requisitos para el reenvío de encabezados
</div>

Asegúrate de que el encabezado `HOST` se reenvíe correctamente en la configuración de tu Worker. Si los encabezados no se reenvían correctamente, las solicitudes de verificación fallarán.

<div id="configure-routing">
  ### Configurar el enrutamiento
</div>

En tu panel de Cloudflare, selecciona **Edit Code** y agrega el siguiente script en el código de tu Worker. Consulta la [documentación de Cloudflare](https://developers.cloudflare.com/workers-ai/get-started/dashboard/#development) para obtener más información sobre cómo editar un Worker.

<Tip>
  Reemplaza `[SUBDOMAIN]` por tu subdominio único, `[YOUR_DOMAIN]` por la URL base de tu sitio web y `/docs` por la subruta que prefieras si fuera distinta.
</Tip>

```javascript
addEventListener("fetch", (event) => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  try {
    const urlObject = new URL(request.url);
    
    // Si la solicitud es a una ruta de verificación de Vercel, deja que pase
    if (urlObject.pathname.startsWith('/.well-known/')) {
      return await fetch(request);
    }
    
    // Si la solicitud es al subdirectorio de docs
    if (/^\/docs/.test(urlObject.pathname)) {
      // Entonces, haz proxy a Mintlify
      const DOCS_URL = "[SUBDOMAIN].mintlify.dev";
      const CUSTOM_URL = "[YOUR_DOMAIN]";

      let url = new URL(request.url);
      url.hostname = DOCS_URL;

      let proxyRequest = new Request(url, request);

      proxyRequest.headers.set("Host", DOCS_URL);
      proxyRequest.headers.set("X-Forwarded-Host", CUSTOM_URL);
      proxyRequest.headers.set("X-Forwarded-Proto", "https");
      // Si despliegas en Vercel, conserva la IP del cliente
      proxyRequest.headers.set("CF-Connecting-IP", request.headers.get("CF-Connecting-IP"));

      return await fetch(proxyRequest);
    }
  } catch (error) {
    // Si no se encuentra ninguna coincidencia, procesa la solicitud normal
    return await fetch(request);
  }
}
```

Selecciona **Deploy** y espera a que los cambios se propaguen.

<Propagating />


<div id="test-your-worker">
  ### Prueba tu Worker
</div>

Después de desplegar tu código, prueba tu Worker para asegurarte de que redirige a tu documentación de Mintlify.

1. Prueba usando la URL de vista previa del Worker: `your-worker.your-subdomain.workers.dev/docs`
2. Verifica que el Worker redirige a tu documentación de Mintlify y a tu sitio web.

<div id="add-custom-domain">
  ### Agregar dominio personalizado
</div>

1. En tu [panel de Cloudflare](https://dash.cloudflare.com/), ve a tu Worker.
2. Ve a **Settings > Domains & Routes > Add > Custom Domain**.
3. Agrega tu dominio. 

<Tip>
  Recomendamos agregar tu dominio tanto con `www.` como sin él.
</Tip>

Consulta [Add a custom domain](https://developers.cloudflare.com/workers/configuration/routing/custom-domains/#add-a-custom-domain) en la documentación de Cloudflare para más información. 

<div id="resolve-dns-conflicts">
  ### Resolver conflictos de DNS
</div>

Si tu dominio ya apunta a otro servicio, debes eliminar el registro DNS existente. Tu Cloudflare Worker debe estar configurado para controlar todo el tráfico de tu dominio.

1. Elimina el registro DNS existente de tu dominio. Consulta [Eliminar registros DNS](https://developers.cloudflare.com/dns/manage-dns-records/how-to/create-dns-records/#delete-dns-records) en la documentación de Cloudflare para obtener más información.
2. Regresa a tu Worker y añade tu dominio personalizado.

<div id="webflow-custom-routing">
  ## Enrutamiento personalizado en Webflow
</div>

Si usas Webflow para alojar tu sitio principal y quieres servir la documentación de Mintlify en `/docs` en el mismo dominio, tendrás que configurar un enrutamiento personalizado mediante Cloudflare Workers para enrutar todo el tráfico que no sea de docs a tu sitio principal.

<Warning>
  Asegúrate de que tu sitio principal esté configurado en una página de aterrizaje antes de desplegar este Worker, o quienes visiten tu sitio principal verán errores.
</Warning>

1. En Webflow, configura una página de aterrizaje para tu sitio principal, por ejemplo `landing.yoursite.com`. Esta será la página que verán las personas al visitar tu sitio.
2. Despliega tu sitio principal en la página de aterrizaje. Esto garantiza que tu sitio principal siga siendo accesible mientras configuras el Worker.
3. Para evitar conflictos, actualiza cualquier URL absoluta en tu sitio principal para que sea relativa.
4. En Cloudflare, selecciona **Edit Code** y añade el siguiente script en el código de tu Worker.

<Tip> Reemplaza `[SUBDOMAIN]` por tu subdominio único, `[YOUR_DOMAIN]` por la URL base de tu sitio web, `[LANDING_DOMAIN]` por la URL de tu página de aterrizaje y `/docs` por la subruta deseada si fuera distinta. </Tip>

```javascript
  addEventListener("fetch", (event) => {
  event.respondWith(handleRequest(event.request));
  });
  async function handleRequest(request) {
  try {
    const urlObject = new URL(request.url);
    
    // Si la solicitud es a una ruta de verificación de Vercel, deja que pase
    if (urlObject.pathname.startsWith('/.well-known/')) {
      return await fetch(request);
    }
    
    // Si la solicitud es al subdirectorio de docs
    if (/^\/docs/.test(urlObject.pathname)) {
      // Encamina a través de un proxy a Mintlify
      const DOCS_URL = "[SUBDOMAIN].mintlify.dev";
      const CUSTOM_URL = "[YOUR_DOMAIN]";
      let url = new URL(request.url);
      url.hostname = DOCS_URL;
      let proxyRequest = new Request(url, request);
      proxyRequest.headers.set("Host", DOCS_URL);
      proxyRequest.headers.set("X-Forwarded-Host", CUSTOM_URL);
      proxyRequest.headers.set("X-Forwarded-Proto", "https");
      // Si se despliega en Vercel, conserva la IP del cliente
      proxyRequest.headers.set("CF-Connecting-IP", request.headers.get("CF-Connecting-IP"));
      return await fetch(proxyRequest);
    }
    // Envía todo lo demás al sitio principal
    const MAIN_SITE_URL = "[LANDING_DOMAIN]";
    if (MAIN_SITE_URL && MAIN_SITE_URL !== "[LANDING_DOMAIN]") {
      let mainSiteUrl = new URL(request.url);
      mainSiteUrl.hostname = MAIN_SITE_URL;
      return await fetch(mainSiteUrl, {
        method: request.method,
        headers: request.headers,
        body: request.body
      });
    }
  } catch (error) {
    // Si no se encuentra ninguna coincidencia, atiende la solicitud normal
    return await fetch(request);
  }
  }
```

5. Selecciona **Deploy** y espera a que los cambios se propaguen.

<Propagating />
