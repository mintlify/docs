---
title: "Tutorial: Pre-fill support tickets with assistant context"
sidebarTitle: "Pre-fill support tickets"
description: "Reduce support burden by auto-populating tickets with assistant conversations and relevant documentation"
---

## What you will build

An integration that captures assistant conversations when users need additional help and automatically creates support tickets with full context. The workflow:

1. User interacts with the assistant on your documentation site
2. When the assistant can't fully answer their question, user clicks a "Contact Support" link
3. A support ticket is automatically created with:
   - User's original questions
   - Assistant's responses
   - Links to relevant documentation
   - Conversation thread ID for reference

This reduces support burden by giving your team full context before they respond, and helps identify documentation gaps.

## Prerequisites

- Mintlify Pro or Custom plan
- Support platform account (this guide uses Zendesk as an example, but the approach works for any platform)
- Support platform API credentials
- Basic knowledge of your support platform's API

### Get your support platform API credentials

**For Zendesk:**
1. Navigate to Admin Center → Apps and integrations → APIs → Zendesk API
2. Enable token access
3. Click the **Add API token** button
4. Copy and save the token securely
5. Note your Zendesk subdomain (e.g., `yourcompany.zendesk.com`)

For other platforms (Intercom, Freshdesk, etc.), consult their API documentation for authentication setup.

## Understand the assistant data

The Mintlify assistant provides several ways to access conversation data:

### Dashboard export
Export conversation history as CSV from your [assistant dashboard](https://dashboard.mintlify.com/products/assistant). The export includes:
- User queries
- Assistant responses
- Source citations
- Timestamps
- Thread IDs

### Built-in deflection
Configure a deflection email in your [assistant settings](https://dashboard.mintlify.com/products/assistant/settings). When the assistant cannot answer a question, it displays this email to users.

### Custom integration
For programmatic access, you can build a custom contact form that captures the current conversation state and sends it to your support system.

## Build the integration

This guide shows how to build a serverless function that creates support tickets from assistant conversation data.

### Create a contact support page

Add a dedicated contact page to your documentation that captures assistant context when users need help.

Create `contact-support.mdx` in your docs:

```mdx contact-support.mdx
---
title: "Contact Support"
description: "Get help from our support team"
---

If the assistant couldn't answer your question, our support team is here to help.

<form action="/api/create-ticket" method="POST">
  <input type="hidden" name="conversation_context" id="conversation_context" />
  <label for="email">Your email:</label>
  <input type="email" name="email" id="email" required />

  <label for="subject">Subject:</label>
  <input type="text" name="subject" id="subject" required />

  <label for="description">How can we help?</label>
  <textarea name="description" id="description" rows="4" required></textarea>

  <button type="submit">Submit</button>
</form>

<script>
  // Capture assistant conversation context if available
  if (typeof window !== 'undefined' && window.localStorage) {
    const assistantThread = localStorage.getItem('mintlify_assistant_thread');
    if (assistantThread) {
      document.getElementById('conversation_context').value = assistantThread;
    }
  }
</script>
```

### Create the ticket creation endpoint

Create a serverless function to handle ticket creation. This example uses Vercel, but you can adapt it for any platform.

Create `api/create-ticket.js`:

```javascript api/create-ticket.js
export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { email, subject, description, conversation_context } = req.body;

  // Parse conversation context if provided
  let contextNote = '';
  if (conversation_context) {
    try {
      const context = JSON.parse(conversation_context);
      contextNote = formatConversationContext(context);
    } catch (e) {
      console.error('Failed to parse conversation context:', e);
    }
  }

  // Create Zendesk ticket
  const ticketData = {
    ticket: {
      subject: subject,
      comment: {
        body: `${description}\n\n---\n\nAssistant Conversation History:\n${contextNote}`
      },
      requester: {
        email: email,
        name: email.split('@')[0]
      },
      priority: 'normal',
      tags: ['assistant_escalation']
    }
  };

  try {
    const response = await fetch(
      `https://${process.env.ZENDESK_SUBDOMAIN}.zendesk.com/api/v2/tickets.json`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Basic ${Buffer.from(
            `${process.env.ZENDESK_EMAIL}/token:${process.env.ZENDESK_API_TOKEN}`
          ).toString('base64')}`
        },
        body: JSON.stringify(ticketData)
      }
    );

    if (!response.ok) {
      throw new Error(`Zendesk API error: ${response.status}`);
    }

    const result = await response.json();

    return res.status(200).json({
      success: true,
      ticket_id: result.ticket.id,
      ticket_url: `https://${process.env.ZENDESK_SUBDOMAIN}.zendesk.com/agent/tickets/${result.ticket.id}`
    });

  } catch (error) {
    console.error('Error creating ticket:', error);
    return res.status(500).json({
      error: 'Failed to create support ticket',
      message: error.message
    });
  }
}

function formatConversationContext(context) {
  if (!context.messages || context.messages.length === 0) {
    return 'No conversation history available.';
  }

  return context.messages
    .map((msg, index) => {
      const role = msg.role === 'user' ? 'User' : 'Assistant';
      const sources = msg.sources
        ? `\nSources: ${msg.sources.map(s => s.url).join(', ')}`
        : '';

      return `${index + 1}. ${role}: ${msg.content}${sources}`;
    })
    .join('\n\n');
}
```

### Configure environment variables

Add your support platform credentials to your environment:

```bash .env
ZENDESK_SUBDOMAIN=yourcompany
ZENDESK_EMAIL=support@yourcompany.com
ZENDESK_API_TOKEN=your_api_token_here
```

For Vercel, add these in your project settings under Environment Variables.

### Link from the assistant

Update your assistant configuration to direct users to your contact page:

1. Navigate to your [assistant settings](https://dashboard.mintlify.com/products/assistant/settings)
2. In the deflection email section, you can include a link to your contact page: "Visit [our support page](https://docs.yourcompany.com/contact-support) for help"

## Test the integration

1. Navigate to your documentation site
2. Open the assistant and ask a question it might not fully answer
3. Click the contact support link
4. Fill out the form and submit
5. Verify the ticket was created in your support system

### Verify the integration

Check the following to confirm the workflow is working:

- Ticket appears in your support platform (Zendesk, etc.)
- Ticket includes the user's description
- Ticket includes formatted conversation context from the assistant
- Ticket is tagged appropriately for tracking
- Support team can access all relevant information

## Optional enhancements

### Add user identification

If users are authenticated on your docs site, include their user ID for better tracking:

```javascript
const ticketData = {
  ticket: {
    subject: subject,
    comment: { body: description },
    requester: {
      email: email,
      name: req.body.user_name || email.split('@')[0]
    },
    custom_fields: [
      { id: 'user_id_field_id', value: req.body.user_id }
    ],
    tags: ['assistant_escalation', 'authenticated_user']
  }
};
```

### Analyze deflection patterns

Use the assistant dashboard to export conversation data and analyze:
- What questions lead to support tickets?
- Which documentation pages are most frequently cited before escalation?
- What topics have low deflection rates (need better docs)?

Export data from your [assistant dashboard](https://dashboard.mintlify.com/products/assistant) and analyze with your preferred tool.

### Integrate with multiple platforms

Adapt the serverless function to support multiple platforms based on configuration:

```javascript
const PLATFORM_HANDLERS = {
  zendesk: createZendeskTicket,
  intercom: createIntercomConversation,
  freshdesk: createFreshdeskTicket
};

const platform = process.env.SUPPORT_PLATFORM || 'zendesk';
const handler = PLATFORM_HANDLERS[platform];

if (!handler) {
  throw new Error(`Unsupported platform: ${platform}`);
}

await handler(ticketData);
```

## Troubleshooting

### Tickets not being created

- Verify your API credentials are correct and have proper permissions
- Check that your support platform API is accessible from your serverless function
- Review serverless function logs for error messages
- Test API credentials with a simple curl command:
  ```bash
  curl https://yourcompany.zendesk.com/api/v2/tickets.json \
    -u email/token:api_token \
    -X GET
  ```

### Conversation context is empty

- Verify the assistant conversation is being stored in localStorage
- Check browser console for JavaScript errors
- Ensure the contact form is properly capturing the hidden field value
- Test with a fresh conversation in the assistant

### Tickets missing information

- Check the `formatConversationContext` function is parsing data correctly
- Verify the conversation context JSON structure matches your expectations
- Add console logging to debug the data being sent
- Review the support platform's field requirements

### Authentication errors

- Confirm your API token hasn't expired
- Verify the subdomain is correct (no `https://` prefix)
- Check that email/token format matches platform requirements (e.g., `email/token:api_token` for Zendesk)
- Ensure API token has permission to create tickets
