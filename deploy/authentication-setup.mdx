---
title: "Authentication setup"
description: "Control access to your documentation by authenticating users."
keywords: ['authentication', 'auth', 'OAuth', 'JWT', 'password']
---

<Info>
  [Pro plans](https://mintlify.com/pricing?ref=authentication) include password authentication.

  [Custom plans](https://mintlify.com/pricing?ref=authentication) include all authentication methods.
</Info>

Authentication requires users to log in before accessing your documentation.

## Authentication modes

Choose between full and partial authentication modes based on your access control needs.

**Full authentication**: All pages are protected. Users must log in before accessing any content.

**Partial authentication**: Some pages are publicly viewable while others require authentication. Users can browse public content freely and authenticate only when accessing protected pages.

When configuring any handshake method below, you'll select either **Full authentication** or **Partial authentication** in your dashboard settings.

## Understanding token types

Different authentication methods use different token types. Understanding these tokens helps you configure authentication correctly and troubleshoot issues.

### Access tokens (OAuth)

Access tokens are short-lived credentials issued by your OAuth server after successful authentication. Mintlify uses these tokens to verify user identity and retrieve user information.

**Where to configure:**
- **Token URL**: The endpoint where Mintlify exchanges authorization codes for access tokens
- **Info API URL**: Your endpoint that accepts access tokens and returns user data

**Configuration example:**
```json
{
  "tokenUrl": "https://auth.foo.com/oauth/token",
  "infoApiUrl": "https://api.foo.com/user-info"
}
```

**How it works:**
1. User authenticates with your OAuth provider
2. Mintlify receives an authorization code
3. Mintlify exchanges the code for an access token at your Token URL
4. Mintlify calls your Info API URL with the access token to get user data

**Advanced access token options:**
- **Token refresh**: Configure refresh tokens to extend sessions without re-authentication
- **Token introspection**: Validate tokens by calling your OAuth server's introspection endpoint
- **Custom headers**: Pass additional headers with token requests (contact support for configuration)
- **Token caching**: Mintlify caches tokens based on expiration times to reduce API calls

### API keys

API keys are long-lived credentials used for server-to-server authentication. When you create a user info endpoint for OAuth, you'll typically validate the access token rather than using API keys directly.

**Where to configure:**
API keys are not directly configured in Mintlify's dashboard. Instead, they're used in your backend services that Mintlify calls.

**Usage example:**
```javascript
// Your Info API endpoint validating an access token
app.get('/user-info', async (req, res) => {
  const accessToken = req.headers.authorization?.replace('Bearer ', '');
  
  // Validate the access token with your OAuth server
  const userInfo = await validateToken(accessToken);
  
  res.json({
    content: {
      firstName: userInfo.firstName,
      lastName: userInfo.lastName
    },
    groups: userInfo.groups
  });
});
```

### Bearer tokens

Bearer tokens are a type of access token transmitted in the HTTP Authorization header. Mintlify uses bearer tokens when calling your Info API URL.

**Format:**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Where to expect them:**
Your Info API endpoint will receive bearer tokens in the Authorization header. Your endpoint should validate these tokens before returning user data.

**Implementation example:**
```typescript
// Express middleware to validate bearer tokens
function validateBearerToken(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Missing or invalid authorization header' });
  }
  
  const token = authHeader.substring(7); // Remove 'Bearer ' prefix
  
  // Validate token with your OAuth server
  try {
    const userInfo = await oauthServer.validateToken(token);
    req.user = userInfo;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

app.get('/user-info', validateBearerToken, (req, res) => {
  res.json({
    content: {
      firstName: req.user.firstName,
      lastName: req.user.lastName
    },
    groups: req.user.groups
  });
});
```

### JWT tokens

JWT (JSON Web Token) tokens are self-contained tokens that include user data and are cryptographically signed. With Mintlify's JWT authentication, you generate and sign JWTs on your server.

**Where to configure:**
- **Private key**: Generated in your Mintlify dashboard and stored securely in your backend
- **Login URL**: The URL where users authenticate before being redirected to your docs

**Configuration steps:**
1. Generate a private key in your dashboard
2. Store the key securely (environment variable, secrets manager)
3. Sign JWTs using the EdDSA algorithm
4. Redirect users to `/login/jwt-callback#{SIGNED_JWT}`

**JWT structure:**
```json
{
  "expiresAt": 1735862400,
  "groups": ["admin", "engineering"],
  "content": {
    "firstName": "Jane",
    "lastName": "Doe",
    "email": "jane@example.com"
  }
}
```

**Complete implementation:**
```typescript
import * as jose from 'jose';

const TWO_WEEKS_IN_MS = 1000 * 60 * 60 * 24 * 7 * 2;
const signingKey = await jose.importPKCS8(process.env.MINTLIFY_PRIVATE_KEY, 'EdDSA');

async function generateMintlifyJWT(user) {
  const payload = {
    expiresAt: Math.floor((Date.now() + TWO_WEEKS_IN_MS) / 1000),
    groups: user.groups,
    content: {
      firstName: user.firstName,
      lastName: user.lastName,
      email: user.email
    }
  };

  const jwt = await new jose.SignJWT(payload)
    .setProtectedHeader({ alg: 'EdDSA' })
    .setExpirationTime('10s') // Short-lived JWT for the redirect
    .sign(signingKey);

  return jwt;
}

// In your login handler
app.post('/docs-login', async (req, res) => {
  // Authenticate user with your existing system
  const user = await authenticateUser(req.body);
  
  // Generate JWT for Mintlify
  const jwt = await generateMintlifyJWT(user);
  
  // Redirect to docs with JWT
  const redirectPath = req.query.redirect || '/';
  res.redirect(`https://docs.foo.com/login/jwt-callback?redirect=${redirectPath}#${jwt}`);
});
```

## Token security best practices

Follow these practices to keep your authentication secure.

### Secure token storage

**Private keys (JWT):**
- Store in environment variables or secrets managers (AWS Secrets Manager, HashiCorp Vault)
- Never commit keys to version control
- Rotate keys periodically (every 90 days recommended)
- Use different keys for development and production

**Client secrets (OAuth):**
- Store securely like private keys
- Restrict access to authorized personnel only
- Rotate if compromised

### Token expiration

**Short-lived tokens:**
- JWT redirect tokens: 10 seconds (just long enough for the redirect)
- OAuth access tokens: 1 hour or less
- Session tokens: 2 weeks maximum

**Example configuration:**
```typescript
const jwt = await new jose.SignJWT(payload)
  .setProtectedHeader({ alg: 'EdDSA' })
  .setExpirationTime('10s') // Short JWT expiration
  .sign(signingKey);

const payload = {
  expiresAt: Math.floor((Date.now() + TWO_WEEKS_IN_MS) / 1000), // Session expiration
  // ... other fields
};
```

### Token transmission

**Always use HTTPS:**
- Never transmit tokens over HTTP
- Ensure your OAuth endpoints use HTTPS
- Verify SSL certificates

**Secure headers:**
```typescript
// Good: Bearer token in Authorization header
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

// Bad: Token in URL query parameter
https://api.foo.com/user-info?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Token validation

**Validate all tokens:**
```typescript
// Validate signature
const verified = await jose.jwtVerify(token, publicKey);

// Validate expiration
if (verified.payload.exp < Date.now() / 1000) {
  throw new Error('Token expired');
}

// Validate issuer and audience
if (verified.payload.iss !== 'your-auth-server') {
  throw new Error('Invalid issuer');
}
```

**Check token scope:**
```typescript
// Ensure token has required scopes
const requiredScopes = ['docs.read', 'user.info'];
const tokenScopes = verified.payload.scope.split(' ');

if (!requiredScopes.every(scope => tokenScopes.includes(scope))) {
  throw new Error('Insufficient permissions');
}
```

### Rate limiting

Implement rate limiting on your token endpoints to prevent abuse:

```typescript
import rateLimit from 'express-rate-limit';

const tokenLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per window
  message: 'Too many token requests, please try again later'
});

app.post('/oauth/token', tokenLimiter, handleTokenRequest);
```

## Common token issues

### Issue: "Invalid token" errors

**Symptoms:**
- Users see authentication errors
- Logs show 401 Unauthorized responses

**Causes and solutions:**

**Expired tokens:**
```typescript
// Check token expiration
const payload = jose.decodeJwt(token);
console.log('Token expires at:', new Date(payload.exp * 1000));

// Solution: Increase session expiration or implement token refresh
const payload = {
  expiresAt: Math.floor((Date.now() + FOUR_WEEKS_IN_MS) / 1000), // Longer session
  // ...
};
```

**Wrong signing algorithm:**
```typescript
// Wrong: Using HS256 instead of EdDSA
const jwt = await new jose.SignJWT(payload)
  .setProtectedHeader({ alg: 'HS256' }) // ❌ Wrong algorithm
  .sign(signingKey);

// Correct: Use EdDSA for Mintlify JWT
const jwt = await new jose.SignJWT(payload)
  .setProtectedHeader({ alg: 'EdDSA' }) // ✅ Correct algorithm
  .sign(signingKey);
```

**Incorrect key format:**
```typescript
// Ensure you're using PKCS8 format for EdDSA keys
const signingKey = await jose.importPKCS8(
  process.env.MINTLIFY_PRIVATE_KEY,
  'EdDSA'
);
```

### Issue: OAuth redirect loops

**Symptoms:**
- Users get stuck in redirect loops
- Browser shows "too many redirects" error

**Causes and solutions:**

**Incorrect redirect URL:**
```json
// Wrong: Missing /login/jwt-callback path
"redirectUrl": "https://docs.foo.com"

// Correct: Include the callback path
"redirectUrl": "https://docs.foo.com/login/jwt-callback"
```

**Missing redirect parameter:**
```typescript
// Preserve the original destination
const redirectPath = req.query.redirect || '/';
res.redirect(`https://docs.foo.com/login/jwt-callback?redirect=${redirectPath}#${jwt}`);
```

### Issue: User info not loading

**Symptoms:**
- Authentication succeeds but user data is empty
- Personalization features don't work

**Causes and solutions:**

**Info API URL not configured:**
Check your OAuth settings and ensure the Info API URL is set.

**Info API returning wrong format:**
```typescript
// Wrong format
{
  "firstName": "Jane",
  "lastName": "Doe"
}

// Correct format
{
  "content": {
    "firstName": "Jane",
    "lastName": "Doe"
  },
  "groups": ["engineering"]
}
```

**Bearer token not validated:**
```typescript
// Your Info API must validate the bearer token
app.get('/user-info', async (req, res) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  // Validate token with your OAuth server
  const userInfo = await oauthServer.introspect(token);
  
  if (!userInfo.active) {
    return res.status(401).json({ error: 'Invalid token' });
  }
  
  res.json({
    content: {
      firstName: userInfo.firstName,
      lastName: userInfo.lastName
    },
    groups: userInfo.groups
  });
});
```

### Issue: Scope errors

**Symptoms:**
- OAuth flow fails with "insufficient scope" error
- User info endpoint returns 403 Forbidden

**Causes and solutions:**

**Incomplete scope configuration:**
```json
// Wrong: Partial scope string
"scopes": ["users.docs"]

// Correct: Complete scope string including provider prefix
"scopes": ["provider.users.docs"]
```

**Multiple scopes:**
```json
// Configure multiple scopes if needed
"scopes": ["provider.users.docs", "provider.users.profile", "provider.users.email"]
```

**Scope validation in Info API:**
```typescript
// Validate that the token has required scopes
app.get('/user-info', async (req, res) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  const tokenData = await oauthServer.introspect(token);
  
  const requiredScope = 'provider.users.docs';
  if (!tokenData.scope.includes(requiredScope)) {
    return res.status(403).json({ 
      error: 'Insufficient scope',
      required: requiredScope,
      provided: tokenData.scope
    });
  }
  
  // Return user info
});
```

### Issue: CORS errors with Info API

**Symptoms:**
- Browser console shows CORS errors
- Info API requests fail from the docs site

**Solution:**
```typescript
// Add CORS headers to your Info API
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'https://docs.foo.com');
  res.header('Access-Control-Allow-Headers', 'Authorization, Content-Type');
  res.header('Access-Control-Allow-Methods', 'GET, OPTIONS');
  
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  
  next();
});
```

## Configure authentication

Select the handshake method that you want to configure.

<Tabs>
<Tab title="Password">
<Info>
Password authentication provides access control only and does **not** support content personalization.
</Info>

### Prerequisites

* Your security requirements allow sharing passwords among users.

### Implementation

<Steps>
  <Step title="Create a password.">
    1. In your dashboard, go to [Authentication](https://dashboard.mintlify.com/settings/deployment/authentication).
    2. Select **Full Authentication** or **Partial Authentication**.
    3. Select **Password**.
    4. Enter a secure password.
    5. Select **Save changes**.
  </Step>
  <Step title="Distribute access.">
    Securely share the password and documentation URL with authorized users.
  </Step>
</Steps>

### Example

Your documentation is hosted at `docs.foo.com` and you need basic access control without tracking individual users. You want to prevent public access while keeping setup simple. 

**Create a strong password** in your dashboard. **Share credentials** with authorized users. That's it!
</Tab>
<Tab title="Mintlify dashboard">
### Prerequisites

* Everyone who needs to access your documentation must be a member of your Mintlify organization.

### Implementation

<Steps>
  <Step title="Enable Mintlify dashboard authentication.">
    1. In your dashboard, go to [Authentication](https://dashboard.mintlify.com/settings/deployment/authentication).
    2. Select **Full Authentication** or **Partial Authentication**.
    3. Select **Mintlify Auth**.
    4. Select **Enable Mintlify Auth**.
  </Step>
  <Step title="Add authorized users.">
    1. In your dashboard, go to [Members](https://dashboard.mintlify.com/settings/organization/members).
    2. Add each person who should have access to your documentation.
    3. Assign appropriate roles based on their editing permissions.
  </Step>
</Steps>

### Example

Your documentation is hosted at `docs.foo.com` and your entire team has access to your dashboard. You want to restrict access to team members only.

**Enable Mintlify authentication** in your dashboard settings.

**Verify team access** by checking that all team members are added to your organization.
</Tab>
<Tab title="OAuth 2.0">
### Prerequisites

* An OAuth or OIDC server that supports the Authorization Code Flow.
* Ability to create an API endpoint accessible by OAuth access tokens (optional, to enable personalization features).

### Implementation

<Steps>
  <Step title="Configure your OAuth settings.">
    1. In your dashboard, go to [Authentication](https://dashboard.mintlify.com/settings/deployment/authentication).
    2. Select **Full Authentication** or **Partial Authentication**.
    3. Select **OAuth** and configure these fields:
      * **Authorization URL**: Your OAuth endpoint.
      * **Client ID**: Your OAuth 2.0 client identifier.
      * **Client Secret**: Your OAuth 2.0 client secret.
      * **Scopes**: Permissions to request. Copy the **entire** scope string (for example, for a scope like `provider.users.docs`, copy the complete `provider.users.docs`). Use multiple scopes if you need different access levels.
      * **Token URL**: Your OAuth token exchange endpoint.
      * **Info API URL** (optional): Endpoint on your server that Mintlify calls to retrieve user info for personalization. If omitted, the OAuth flow will only be used to verify identity and the user info will be empty.
      * **Logout URL**: The native logout URL for your OAuth provider. If your provider has a `returnTo` or similar parameter, point it back to your docs URL.
    4. Select **Save changes**.
  </Step>
  <Step title="Configure your OAuth server.">
    1. Copy the **Redirect URL** from your [authentication settings](https://dashboard.mintlify.com/settings/deployment/authentication).
    2. Add the redirect URL as an authorized redirect URL for your OAuth server.
  </Step>
  <Step title="Create your user info endpoint (optional).">
    To enable personalization features, create an API endpoint that:
    * Accepts OAuth access tokens for authentication.
    * Returns user data in the `User` format. See [User data format](/deploy/personalization-setup#user-data-format) for more information.
    
    Add this endpoint URL to the **Info API URL** field in your [authentication settings](https://dashboard.mintlify.com/settings/deployment/authentication).
  </Step>
</Steps>

### Example

Your documentation is hosted at `foo.com/docs` and you have an existing OAuth server at `auth.foo.com` that supports the Authorization Code Flow.

**Configure your OAuth server details** in your dashboard:
- **Authorization URL**: `https://auth.foo.com/authorization`
- **Client ID**: `ydybo4SD8PR73vzWWd6S0ObH`
- **Scopes**: `['provider.users.docs']`
- **Token URL**: `https://auth.foo.com/exchange`
- **Info API URL**: `https://api.foo.com/docs/user-info`
- **Logout URL**: `https://auth.foo.com/logout?returnTo=https%3A%2F%2Ffoo.com%2Fdocs`

**Create a user info endpoint** at `api.foo.com/docs/user-info`, which requires an OAuth access token with the `provider.users.docs` scope, and returns:

```json
{
  "content": {
    "firstName": "Jane",
    "lastName": "Doe"
  },
  "groups": ["engineering", "admin"]
}
```

**Configure your OAuth server to allow redirects** to your callback URL.
</Tab>
<Tab title="JWT">
### Prerequisites

* An authentication system that can generate and sign JWTs.
* A backend service that can create redirect URLs.

### Implementation

<Steps>
  <Step title="Generate a private key.">
    1. In your dashboard, go to [Authentication](https://dashboard.mintlify.com/settings/deployment/authentication).
    2. Select **Full Authentication** or **Partial Authentication**.
    3. Select **JWT**.
    4. Enter the URL of your existing login flow and select **Save changes**.
    5. Select **Generate new key**.
    6. Store your key securely where it can be accessed by your backend.
  </Step>
  <Step title="Integrate Mintlify authentication into your login flow.">
    Modify your existing login flow to include these steps after user authentication:
    
    * Create a JWT containing the authenticated user's info in the `User` format. See [User data format](/deploy/personalization-setup#user-data-format) for more information.
    * Sign the JWT with your secret key, using the EdDSA algorithm.
    * Create a redirect URL back to the `/login/jwt-callback` path of your docs, including the JWT as the hash.
  </Step>
</Steps>

### Example

Your documentation is hosted at `docs.foo.com` with an existing authentication system at `foo.com`. You want to extend your login flow to grant access to the docs while keeping your docs separate from your dashboard (or you don't have a dashboard).

Create a login endpoint at `https://foo.com/docs-login` that extends your existing authentication.

After verifying user credentials:
* Generate a JWT with user data in Mintlify's format.
* Sign the JWT and redirect to `https://docs.foo.com/login/jwt-callback#{SIGNED_JWT}`.

<CodeGroup>
```ts TypeScript
import * as jose from 'jose';
import { Request, Response } from 'express';

const TWO_WEEKS_IN_MS = 1000 * 60 * 60 * 24 * 7 * 2;

const signingKey = await jose.importPKCS8(process.env.MINTLIFY_PRIVATE_KEY, 'EdDSA');

export async function handleRequest(req: Request, res: Response) {
  const user = {
    expiresAt: Math.floor((Date.now() + TWO_WEEKS_IN_MS) / 1000), // 2 week session expiration
    groups: res.locals.user.groups,
    content: {
      firstName: res.locals.user.firstName,
      lastName: res.locals.user.lastName,
    },
  };

  const jwt = await new jose.SignJWT(user)
    .setProtectedHeader({ alg: 'EdDSA' })
    .setExpirationTime('10 s') // 10 second JWT expiration
    .sign(signingKey);

  return res.redirect(`https://docs.foo.com/login/jwt-callback#${jwt}`);
}
```

```python Python
import jwt # pyjwt
import os

from datetime import datetime, timedelta
from fastapi.responses import RedirectResponse

private_key = os.getenv(MINTLIFY_JWT_PEM_SECRET_NAME, '')

@router.get('/auth')
async def return_mintlify_auth_status(current_user):
  jwt_token = jwt.encode(
    payload={
      'exp': int((datetime.now() + timedelta(seconds=10)).timestamp()),    # 10 second JWT expiration
      'expiresAt': int((datetime.now() + timedelta(weeks=2)).timestamp()), # 1 week session expiration
      'groups': ['admin'] if current_user.is_admin else [],
      'content': {
        'firstName': current_user.first_name,
        'lastName': current_user.last_name,
      },
    },
    key=private_key,
    algorithm='EdDSA'
  )

  return RedirectResponse(url=f'https://docs.foo.com/login/jwt-callback#{jwt_token}', status_code=302)
```
</CodeGroup>

### Redirect unauthenticated users

When an unauthenticated user tries to access a protected page, their intended destination is preserved in the redirect to your login URL:

1. User attempts to visit a protected page: `https://docs.foo.com/quickstart`.
2. Redirect to your login URL with a redirect query parameter: `https://foo.com/docs-login?redirect=%2Fquickstart`.
3. After authentication, redirect to `https://docs.foo.com/login/jwt-callback?redirect=%2Fquickstart#{SIGNED_JWT}`.
4. User lands in their original destination.
</Tab>
</Tabs>

## Make pages public

When using partial authentication, all pages are protected by default. You can make specific pages viewable without authentication at the page or group level with the `public` property.

### Individual pages

To make a page public, add `public: true` to the page's frontmatter.

```mdx Public page example
---
title: "Public page"
public: true
---
```

### Groups of pages

To make all pages in a group public, add `"public": true` beneath the group's name in the `navigation` object of your `docs.json`.

```json Public group example
{
  "navigation": {
    "groups": [
      {
        "group": "Public group",
        "public": true,
        "icon": "play",
        "pages": [
          "quickstart",
          "installation",
          "settings"
        ]
      },
      {
        "group": "Private group",
        "icon": "pause",
        "pages": [
          "private-information",
          "secret-settings"
        ]
      }
    ]
  }
}
```

## Control access with groups

When you use OAuth or JWT authentication, you can restrict specific pages to certain user groups. This is useful when you want different users to see different content based on their role or attributes.

Groups are managed through user data passed during authentication.

```json Example user info highlight={2}
{
  "groups": ["admin", "beta-users"],
  "content": {
    "firstName": "Jane",
    "lastName": "Doe"
  }
}
```

Specify which groups can access specific pages using the `groups` property in frontmatter.

```mdx Example page restricted to the admin group highlight={3}
---
title: "Admin dashboard"
groups: ["admin"]
---
```

Users must belong to at least one of the listed groups to access the page. If a user tries to access a page without the required group, they'll receive a 404 error.

### Interaction with authentication modes

Groups work differently depending on your authentication mode.

**Full authentication with groups:**
- All pages require authentication.
- Pages without a `groups` property are accessible to all authenticated users.
- Pages with a `groups` property are only accessible to authenticated users in those groups.

**Partial authentication with groups:**
- Pages require authentication unless you make them public.
- Pages with `public: true` and no `groups` are accessible to everyone.
- Pages with `groups` (with or without `public: true`) are only accessible to authenticated users in those groups.

```mdx Anyone can view this page
---
title: "Public guide"
public: true
---
```

```mdx Only authenticated users can view this page
---
title: "API reference"
---

```mdx Only authenticated users in the pro or enterprise groups can view this page
---
title: "Advanced configurations"
groups: ["pro", "enterprise"]
---
```
