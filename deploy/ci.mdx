---
title: "TEST: CI checks"
description: "Automate broken link checks, linting, and grammar validation in CI/CD."
keywords: ["continuous integration", "CI/CD", "checks", "Vale", "linter"]
---

<Info>
  [Pro and Custom plans](https://mintlify.com/pricing?ref=docs-ci) include CI checks for GitHub repositories.
</Info>

Use CI checks to lint your docs for errors and provide warnings before you deploy. Mintlify CI checks run on pull requests against a configured deployment branch.

CI checks are an essential part of maintaining high-quality documentation. They help catch issues early in the development process, before changes are merged into your main branch. By automating these checks, you can ensure consistency across your documentation, maintain style guidelines, and prevent broken links from reaching production. This automated validation process saves time for your team and improves the overall quality of your documentation.

The CI check system integrates seamlessly with your existing GitHub workflow. When a pull request is opened or updated, Mintlify automatically runs the configured checks and reports the results directly in the GitHub interface. This means your team can review documentation changes alongside code changes, with immediate feedback on any issues that need to be addressed.

CI checks can be customized to match your team's workflow. You can choose which checks to enable, set their severity levels, and configure them to either warn about issues or block merges when problems are detected. This flexibility allows you to gradually adopt stricter documentation standards or maintain different requirements for different types of changes.

## Installation

To begin, follow the steps on the [GitHub](/deploy/github) page.

Installing CI checks for your documentation is a straightforward process that builds on your existing GitHub integration. The installation process requires minimal configuration and can be completed in just a few minutes. Once installed, the CI checks will automatically run on every pull request, providing immediate feedback to your team.

The installation process involves connecting your GitHub repository to Mintlify and configuring the appropriate permissions. Mintlify needs read access to your repository to analyze your documentation files and write access to post check results back to your pull requests. This integration is secure and follows GitHub's best practices for third-party applications.

After installation, you'll be able to see CI check results directly in your GitHub pull request interface. Each check runs independently and reports its status, making it easy to identify and fix specific issues. The checks are designed to be fast and efficient, typically completing within seconds to minutes depending on the size of your documentation.

<Tip>
  Only access to the repository where your documentation content exists is required, so it is highly recommended to only grant access to that repository. 
</Tip>

## Configuration

Configure the CI checks enabled for a deployment by navigating to the [Add-ons](https://dashboard.mintlify.com/products/addons) page of your dashboard. Enable the checks that you want to run.

The configuration interface provides a comprehensive view of all available CI checks and their current status. You can enable or disable checks individually, allowing you to tailor the CI system to your specific needs. This granular control means you can start with basic checks and gradually add more sophisticated validation as your documentation practices mature.

When enabling checks, you can choose to run them at a `Warning` or `Blocking` level.

- A `Warning` level check will never provide a failure status, even if there is an error or suggestions. This is ideal when you're first introducing a new check to your team, as it allows developers to see the feedback without blocking their workflow. Warning-level checks help build awareness of documentation standards without creating friction in the development process. You can use this mode to gather data about common issues before deciding to enforce stricter rules.

- A `Blocking` level check will provide a failure status if there is an error or suggestions. This mode is appropriate for critical checks that must pass before code can be merged. Blocking checks ensure that your documentation maintains a minimum quality standard and that serious issues like broken links are caught before deployment. When a blocking check fails, the pull request cannot be merged until the issues are resolved, making it an effective enforcement mechanism for documentation quality.

The choice between warning and blocking levels depends on your team's workflow and documentation maturity. Many teams start with warning-level checks to build familiarity and gradually transition to blocking checks as documentation practices improve. You can also use different levels for different checks - for example, making broken link checks blocking while keeping style checks at the warning level.

## Available CI checks

### Broken links

Similar to how the [CLI link checker](/installation#find-broken-links) works on your local machine, the 
broken link CI check automatically searches your documentation content for broken internal links.

Broken links are one of the most common and frustrating issues in documentation. They create a poor user experience, damage credibility, and can prevent users from finding the information they need. The broken link checker helps prevent these issues by automatically scanning all internal links in your documentation and verifying that they point to valid pages.

The broken link checker is intelligent and understands the structure of your documentation. It validates links to other MDX pages, anchors within pages, and references to images and other assets. The checker also understands relative and absolute paths, ensuring that links work correctly regardless of how they're formatted. This comprehensive validation catches issues that might be missed during manual review.

When the broken link checker finds an issue, it provides detailed information about the problem. You'll see which file contains the broken link, what the link text is, and where it's trying to point. This detailed feedback makes it easy to fix issues quickly. The checker also distinguishes between different types of link problems, such as links to pages that don't exist versus links with incorrect anchor references.

To see the results of this check, visit GitHub's check results page for a specific commit. The results are presented in a clear, actionable format that makes it easy to understand what needs to be fixed. Each broken link is listed with its location and the reason it failed validation. You can click through to see the specific line in your documentation where the issue occurs, making fixes straightforward and efficient.

### Vale

[Vale](https://vale.sh/) is an open source rule-based prose linter which supports a range of document types, including Markdown and MDX. Use Vale to check for consistency of style and tone in your documentation.

Vale is a powerful tool for maintaining consistent writing style across your documentation. It can check for grammar issues, style violations, terminology consistency, and adherence to your organization's writing guidelines. By automating these checks, Vale helps ensure that your documentation maintains a professional, consistent voice regardless of how many contributors are involved.

The Vale linter works by applying a set of rules to your documentation content. These rules can check for everything from simple issues like passive voice and complex words to more sophisticated concerns like brand terminology and tone consistency. Vale's rule-based approach means it can be customized to match your organization's specific style guide and documentation standards.

One of Vale's key strengths is its flexibility. You can use pre-built style guides from major organizations like Microsoft, Google, and write.good, or create your own custom rules. This flexibility allows you to enforce your organization's unique terminology, preferred phrasings, and writing conventions. Vale can also be configured to check different types of content with different rules, allowing for more formal language in API documentation and more conversational language in tutorials.

Mintlify supports automatically running Vale in a CI check and displaying the results as a check status. This integration means you get the full power of Vale's linting capabilities without needing to set up and maintain your own CI infrastructure. The results are displayed directly in your GitHub pull requests, making it easy for contributors to see and address style issues before merging their changes.

#### Configuration
If you have a `.vale.ini` file in the root content directory of your deployment, the Vale CI check uses that configuration file and any configuration files in your specified `stylesPath`.

The Vale configuration file uses INI format and provides extensive control over how Vale analyzes your documentation. You can specify which style guides to use, set the minimum alert level for issues, define which parts of your documents to ignore, and configure custom vocabularies. This configuration flexibility allows you to tailor Vale's behavior to match your documentation needs precisely.

When you provide your own Vale configuration, Mintlify respects all your settings and uses them exactly as specified. This means you can develop and test your Vale configuration locally, then deploy it to CI with confidence that it will behave the same way. The configuration file also supports comments, making it easy to document why specific rules are enabled or disabled.

If you don't have a Vale config file, the default configuration automatically loads. The default configuration is designed to work well for most documentation projects and includes sensible defaults for MDX files. It includes basic style checking, ignores code blocks and other technical content that shouldn't be linted, and uses a vocabulary that includes common technical terms. This default configuration provides immediate value without requiring any setup, while still allowing you to customize it later as your needs evolve.

````mdx Default vale.ini configuration expandable
# Top level styles
StylesPath = /app/styles
MinAlertLevel = suggestion
# Inline HTML tags to ignore (code/tt for code snippets, img/url for links/images, a for anchor tags)
IgnoredScopes = code, tt, img, url, a
SkippedScopes = script, style, pre, figure

# Vocabularies
Vocab = Mintlify

# Packages
Packages = MDX

# Only match MDX
[*.mdx]
BasedOnStyles = Vale
Vale.Terms = NO # Enforces really harsh capitalization rules, keep off

# Ignore JSX/MDX-specific syntax patterns
# `import ...`, `export ...`
# `<Component ... />`
# `<Component>...</Component>`
# `{ ... }`
TokenIgnores = (?sm)((?:import|export) .+?$), \
(?<!`)(<\w+ ?.+ ?\/>)(?!`), \
(<[A-Z]\w+>.+?<\/[A-Z]\w+>)

# Exclude multiline JSX and curly braces
# `<Component \n ... />`
BlockIgnores = (?sm)^(<\w+\n .*\s\/>)$, \
(?sm)^({.+.*})
````

The default Vale vocabulary includes the following words.

```text Default Vale vocabulary expandable
Mintlify
mintlify
VSCode
openapi
OpenAPI
Github
APIs

repo
npm
dev

Lorem
ipsum
impsum
amet

const
myName
myObject
bearerAuth
favicon
topbar
url
borderRadius
args
modeToggle
ModeToggle
isHidden
autoplay

_italic_
Strikethrough
Blockquotes
Blockquote
Singleline
Multiline

onboarding

async
await
boolean
enum
func
impl
init
instanceof
typeof
params
stdin
stdout
stderr
stdout
stdin
var
const
let
null
undefined
struct
bool

cors
csrf
env
xhr
xhr2
jwt
oauth
websocket
localhost
middleware
runtime
webhook
stdin
stdout

json
yaml
yml
md
txt
tsx
jsx
css
scss
html
png
jpg
svg

cdn
cli
css
dom
dto
env
git
gui
http
https
ide
jvm
mvc
orm
rpc
sdk
sql
ssh
ssl
tcp
tls
uri
url
ux
ui

nodejs
npm
yarn
pnpm
eslint
pytest
golang
rustc
kubectl
mongo
postgres
redis

JavaScript
TypeScript
Python
Ruby
Rust
Go
Golang
Java
Kotlin
Swift
Node.js
NodeJS
Deno

React
Vue
Angular
Next.js
Nuxt
Express
Django
Flask
Spring
Laravel
Redux
Vuex
TensorFlow
PostgreSQL
MongoDB
Redis
PNPM

Docker
Kubernetes
AWS
Azure
GCP
Terraform
Jenkins
CircleCI
GitLab
Heroku

Git
git
GitHub
GitLab
Bitbucket
VSCode
Visual Studio Code
IntelliJ
WebStorm
ESLint
eslint
Prettier
prettier
Webpack
webpack
Vite
vite
Babel
babel
Jest
jest
Mocha
Cypress
Postman

HTTP
HTTPS
OAuth
JWT
GraphQL
REST
WebSocket
TCP/IP

NPM
Yarn
PNPM
Pip
PIP
Cargo
RubyGems

Swagger
OpenAPI
Markdown
MDX
Storybook
TypeDoc
JSDoc

MySQL
PostgreSQL
MongoDB
Redis
Elasticsearch
DynamoDB

Linux
Unix
macOS
iOS

Firefox
Chromium
WebKit

config
ctx
desc
dir
elem
err
len
msg
num
obj
prev
proc
ptr
req
res
str
tmp
val
vars

todo
href
lang
nav
prev
next
toc
```

To add your own vocabulary for the default configuration, create a `styles/config/vocabularies/Mintlify` directory with `accept.txt` and `reject.txt` files.

- `accept.txt`: Words that should be ignored by the Vale linter. For example, product names or uncommon terms.
- `reject.txt`: Words that should be flagged as errors. For example, jargon or words that are not appropriate for the tone of your documentation.

```text Example Vale file structure
/your-project
  |- docs.json
  |- .vale.ini
  |- styles/
    |- config/
      |- vocabularies/
        |- Mintlify/
          |- accept.txt
          |- reject.txt
  |- example-page.mdx
```

```text Example monorepo Vale file structure
/your-monorepo
  |- main.ts
  |- docs/
    |- docs.json
    |- .vale.ini
    |- styles/
      |- config/
      |- vocabularies/
        |- Mintlify/
          |- accept.txt
          |- reject.txt
    |- example-page.mdx
  |- test/
```

<Note>
For security reasons, absolute `stylesPath`, or `stylesPath` which include `..` values aren't supported.

Use relative paths and include the `stylesPath` in your repository.
</Note>

#### Packages
Vale supports a range of [packages](https://vale.sh/docs/keys/packages), which can be used to check for spelling and style errors. Any packages you include in your repository under the correct `stylesPath` are automatically installed and used in your Vale configuration.

For packages not included in your repository, you may specify any packages from the [Vale package registry](https://vale.sh/explorer), and they're automatically downloaded and used in your Vale configuration.

<Note>
For security reasons, automatically downloading packages that aren't from the [Vale package registry](https://vale.sh/explorer) is **not** supported.
</Note>

#### Vale with `MDX`

<Note>
MDX native support requires Vale 3.10.0 or later. Check your Vale version with `vale --version`.
</Note>

To use Vale's in-document comments in MDX files, use MDX-style comments `{/* ... */}`:

```mdx
{/* vale off */}

This text is ignored by Vale

{/* vale on */}
```

Vale automatically recognizes and respects these comments in MDX files without additional configuration. Use comments to skip lines or sections that should be ignored by the linter.
