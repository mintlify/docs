---
title: git rebase
description: Reapply commits on top of another base tip
---

Move or combine commits to create a linear history.

## Syntax

```bash
git rebase [options] [<upstream>] [<branch>]
```

## Description

`git rebase` moves commits from one branch and reapplies them on top of another branch. This creates a cleaner, linear history compared to merging.

## Common usage

Rebase current branch onto main:

```bash
git rebase main
```

Interactive rebase of last 3 commits:

```bash
git rebase -i HEAD~3
```

## Options

<ParamField path="-i, --interactive" type="flag">
  Interactively edit commits
  
  ```bash
  git rebase -i HEAD~3
  ```
</ParamField>

<ParamField path="--continue" type="flag">
  Continue after resolving conflicts
  
  ```bash
  git rebase --continue
  ```
</ParamField>

<ParamField path="--abort" type="flag">
  Cancel rebase and return to original state
  
  ```bash
  git rebase --abort
  ```
</ParamField>

<ParamField path="--skip" type="flag">
  Skip current commit and continue
</ParamField>

<ParamField path="--onto" type="string">
  Rebase onto specific branch
  
  ```bash
  git rebase --onto main feature old-base
  ```
</ParamField>

## Examples

### Basic rebase

```bash
git checkout feature-branch
git rebase main
```

This moves feature-branch commits on top of main.

### Interactive rebase

```bash
git rebase -i HEAD~3
```

Opens editor with options:

```
pick abc123 First commit
pick def456 Second commit
pick ghi789 Third commit
```

Commands:
- `pick` - Use commit as-is
- `reword` - Change commit message
- `edit` - Stop to amend commit
- `squash` - Combine with previous commit
- `fixup` - Like squash but discard message
- `drop` - Remove commit

### Squash commits

Combine multiple commits into one:

```bash
git rebase -i HEAD~3
```

Change to:
```
pick abc123 First commit
squash def456 Second commit
squash ghi789 Third commit
```

### Rebase onto another branch

```bash
git rebase --onto main old-base feature-branch
```

## Rebase vs Merge

### Use rebase when:

- You want a clean, linear history
- Working on a feature branch not yet pushed
- Updating feature branch with main changes
- Cleaning up commits before pull request

### Use merge when:

- Working on public/shared branches
- Want to preserve exact history
- Collaborating with others on same branch

## Handling conflicts

When conflicts occur during rebase:

```bash
git rebase main
# CONFLICT: Fix conflicts in file.txt
```

1. Fix conflicts in your editor
2. Stage resolved files:

```bash
git add file.txt
```

3. Continue rebase:

```bash
git rebase --continue
```

Or abort:

```bash
git rebase --abort
```

## Common workflows

### Update feature branch

```bash
# On feature branch
git fetch origin
git rebase origin/main
```

### Clean up before pull request

```bash
# Interactive rebase to clean history
git rebase -i HEAD~5

# Force push updated branch
git push --force-with-lease
```

### Rebase and push

```bash
git rebase main
git push --force-with-lease
```

<Warning>
After rebasing, you must force push since history has changed. Use `--force-with-lease` for safety.
</Warning>

## Interactive rebase examples

### Reword commit message

```bash
git rebase -i HEAD~1
```

Change `pick` to `reword`, save, then edit message.

### Split a commit

```bash
git rebase -i HEAD~1
```

Change `pick` to `edit`, then:

```bash
git reset HEAD^
git add file1.txt
git commit -m "First part"
git add file2.txt
git commit -m "Second part"
git rebase --continue
```

### Reorder commits

```bash
git rebase -i HEAD~3
```

Reorder lines in the editor.

## Advanced usage

### Autosquash

Mark commits to squash:

```bash
git commit --fixup abc123
git rebase -i --autosquash HEAD~5
```

### Preserve merges

```bash
git rebase --rebase-merges main
```

### Update commit dates

```bash
git rebase --committer-date-is-author-date main
```

## Best practices

- Only rebase commits not yet pushed
- Use interactive rebase to clean history
- Communicate with team before rebasing shared branches
- Use `--force-with-lease` not `--force` when pushing
- Keep commits focused and atomic
- Write clear commit messages
- Test after rebase before pushing

## Undo a rebase

If rebase went wrong:

```bash
# Find previous state
git reflog

# Reset to before rebase
git reset --hard HEAD@{2}
```

## When to avoid rebase

- Never rebase public branches (main, develop)
- Avoid when others are working on same branch
- Skip if unfamiliar with branch history
- Don't rebase if merge conflicts are complex

## Troubleshooting

### Conflicts on every commit

Consider using merge instead:

```bash
git rebase --abort
git merge main
```

### Lost commits after rebase

Use reflog to recover:

```bash
git reflog
git reset --hard <commit-hash>
```

### Push rejected after rebase

Force push with safety check:

```bash
git push --force-with-lease
```

## Related commands

- [git merge](/git/merge) - Alternative to rebase
- [git cherry-pick](/git/cherry-pick) - Apply specific commits
- [git reflog](/git/reflog) - View reference history
- [git reset](/git/reset) - Undo changes
- [git push](/git/push) - Upload rebased commits
